<?xml version="1.0"?>
<!--
  NOTE: User and query level settings are set up in "users.xml" file.
  If you have accidentally specified user-level settings here, server won't start.
  You can either move the settings to the right place inside "users.xml" file
  or add <skip_check_for_incorrect_settings>1</skip_check_for_incorrect_settings> here.
-->
<clickhouse>
  <logger>
    <!-- Possible levels [1]:
      - none (turns off logging)
      - fatal
      - critical
      - error
      - warning
      - notice
      - information
      - debug
      - trace
      - test (not for production usage)
      [1]: https://github.com/pocoproject/poco/blob/poco-1.9.4-release/Foundation/include/Poco/Logger.h#L105-L114
    -->
    <level>{{ clickhouse_logger.level }}</level>
    <log>{{ clickhouse_logger.log }}</log>
    <errorlog>{{ clickhouse_logger.errorlog }}</errorlog>
    <!-- Rotation policy
      See https://github.com/pocoproject/poco/blob/poco-1.9.4-release/Foundation/include/Poco/FileChannel.h#L54-L85
    -->
    <size>{{ clickhouse_logger.size }}</size>
    <count>{{ clickhouse_logger.count }}</count>
    {% if clickhouse_logger.console is defined and clickhouse_logger.console != 'autodetection' -%}
    <console>{{ clickhouse_logger.console }}</console>
    {% else -%}
    <!-- <console>1</console> -->
    {% endif -%}
    <!-- Default behavior is autodetection (log to console if not daemon mode and is tty) -->

    <!-- Per level overrides (legacy):
    For example to suppress logging of the ConfigReloader you can use:
    NOTE: levels.logger is reserved, see below.
    -->
    <!--
    <levels>
      <ConfigReloader>none</ConfigReloader>
    </levels>
    -->
    {% if clickhouse_logger_overrides_legacy is defined %}{{ clickhouse_logger_overrides_legacy }}{% endif %}

    <!-- Per level overrides:
    For example to suppress logging of the RBAC for default user you can use:
    (But please note that the logger name maybe changed from version to version, even after minor upgrade)
    -->
    <!--
    <levels>
      <logger>
      <name>ContextAccess (default)</name>
      <level>none</level>
      </logger>
      <logger>
      <name>DatabaseOrdinary (test)</name>
      <level>none</level>
      </logger>
    </levels>
    -->
    {% if clickhouse_logger_overrides is defined %}{{ clickhouse_logger_overrides }}{% endif %}
  </logger>

  <!-- Add headers to response in options request. OPTIONS method is used in CORS preflight requests. -->
  <!-- It is off by default. Next headers are obligate for CORS.-->
  <!-- http_options_response>
    <header>
      <name>Access-Control-Allow-Origin</name>
      <value>*</value>
    </header>
    <header>
      <name>Access-Control-Allow-Headers</name>
      <value>origin, x-requested-with</value>
    </header>
    <header>
      <name>Access-Control-Allow-Methods</name>
      <value>POST, GET, OPTIONS</value>
    </header>
    <header>
      <name>Access-Control-Max-Age</name>
      <value>86400</value>
    </header>
  </http_options_response -->
  {% if clickhouse_custom_headers_response is defined %}{{ clickhouse_custom_headers_response }}{% endif %}

  <!-- It is the name that will be shown in the clickhouse-client.
    By default, anything with "production" will be highlighted in red in query prompt.
  -->
  <!--display_name>production</display_name-->

  <!-- Port for HTTP API. See also 'https_port' for secure connections.
    This interface is also used by ODBC and JDBC drivers (DataGrip, Dbeaver, ...)
    and by most of web interfaces (embedded UI, Grafana, Redash, ...).
  -->
  <http_port>{{ clickhouse_http_port }}</http_port>

  <!-- Port for interaction by native protocol with:
    - clickhouse-client and other native ClickHouse tools (clickhouse-benchmark, clickhouse-copier);
    - clickhouse-server with other clickhouse-servers for distributed query processing;
    - ClickHouse drivers and applications supporting native protocol
    (this protocol is also informally called as "the TCP protocol");
    See also 'tcp_port_secure' for secure connections.
  -->
  <tcp_port>{{ clickhouse_tcp_port }}</tcp_port>

  <!-- Compatibility with MySQL protocol.
    ClickHouse will pretend to be MySQL for applications connecting to this port.
  -->
  <mysql_port>{{ clickhouse_mysql_port }}</mysql_port>

  <!-- Compatibility with PostgreSQL protocol.
    ClickHouse will pretend to be PostgreSQL for applications connecting to this port.
  -->
  <postgresql_port>{{ clickhouse_postgresql_port }}</postgresql_port>

  <!-- HTTP API with TLS (HTTPS).
    You have to configure certificate to enable this interface.
    See the openSSL section below.
  -->
  <!-- <https_port>8443</https_port> -->
  {% if clickhouse_https_port is defined -%}
  <https_port>{{ clickhouse_https_port }}</https_port>
  {% endif -%}

  <!-- Native interface with TLS.
    You have to configure certificate to enable this interface.
    See the openSSL section below.
  -->
  <!-- <tcp_port_secure>9440</tcp_port_secure> -->
  {% if clickhouse_tcp_port_secure is defined -%}
  <tcp_port_secure>{{ clickhouse_tcp_port_secure }}</tcp_port_secure>
  {% endif -%}

  <!-- Native interface wrapped with PROXYv1 protocol
    PROXYv1 header sent for every connection.
    ClickHouse will extract information about proxy-forwarded client address from the header.
  -->
  <!-- <tcp_with_proxy_port>9011</tcp_with_proxy_port> -->
  {% if clickhouse_tcp_with_proxy_port is defined -%}
  <tcp_with_proxy_port>{{ clickhouse_tcp_with_proxy_port }}</tcp_with_proxy_port>
  {% endif -%}

  <!-- Port for communication between replicas. Used for data exchange.
    It provides low-level data access between servers.
    This port should not be accessible from untrusted networks.
    See also 'interserver_http_credentials'.
    Data transferred over connections to this port should not go through untrusted networks.
    See also 'interserver_https_port'.
  -->
  <interserver_http_port>{{ clickhouse_interserver_http_port }}</interserver_http_port>

  <!-- Port for communication between replicas with TLS.
    You have to configure certificate to enable this interface.
    See the openSSL section below.
    See also 'interserver_http_credentials'.
    -->
  <!-- <interserver_https_port>9010</interserver_https_port> -->
  {% if clickhouse_interserver_https_port is defined -%}
  <interserver_https_port>{{ clickhouse_interserver_https_port }}</interserver_https_port>
  {% endif -%}

  <!-- Hostname that is used by other replicas to request this server.
    If not specified, than it is determined analogous to 'hostname -f' command.
    This setting could be used to switch replication to another network interface
    (the server may be connected to multiple networks via multiple addresses)
  -->
  <!--
  <interserver_http_host>example.yandex.ru</interserver_http_host>
  -->
  {% if clickhouse_interserver_http_host is defined -%}
  <interserver_http_host>{{ clickhouse_interserver_http_host }}</interserver_http_host>
  {% endif -%}

  <!-- You can specify credentials for authenthication between replicas.
    This is required when interserver_https_port is accessible from untrusted networks,
    and also recommended to avoid SSRF attacks from possibly compromised services in your network.
    -->
  <!--<interserver_http_credentials>
    <user>interserver</user>
    <password></password>
  </interserver_http_credentials>-->
  {% if clikhouse_interserver_http_credentials is defined -%}
  <interserver_http_credentials>
    <user>{{ clikhouse_interserver_http_credentials.user }}</user>
    <password>{{ clikhouse_interserver_http_credentials.password }}</password>
  </interserver_http_credentials>
  {% endif -%}

  <!-- Listen specified address.
    Use :: (wildcard IPv6 address), if you want to accept connections both with IPv4 and IPv6 from everywhere.
    Notes:
    If you open connections from wildcard address, make sure that at least one of the following measures applied:
    - server is protected by firewall and not accessible from untrusted networks;
    - all users are restricted to subset of network addresses (see users.xml);
    - all users have strong passwords, only secure (TLS) interfaces are accessible, or connections are only made via TLS interfaces.
    - users without password have readonly access.
    See also: https://www.shodan.io/search?query=clickhouse
  -->
  <!-- <listen_host>::</listen_host> -->

  <!-- Same for hosts without support for IPv6: -->
  <!-- <listen_host>0.0.0.0</listen_host> -->

  <!-- Default values - try listen localhost on IPv4 and IPv6. -->
  <!--
  <listen_host>::1</listen_host>
  <listen_host>127.0.0.1</listen_host>
  -->
  {% if clickhouse_listen_hosts is defined -%}
  {% for host in clickhouse_listen_hosts -%}
    <listen_host>{{ host }}</listen_host>
  {% endfor -%}
  {% endif -%}

  <!-- Don't exit if IPv6 or IPv4 networks are unavailable while trying to listen. -->
  <!-- <listen_try>0</listen_try> -->
  {% if clickhouse_listen_try is defined -%}
  <listen_try>{{ clickhouse_listen_try }}</listen_try>
  {% endif -%}

  <!-- Allow multiple servers to listen on the same address:port. This is not recommended.
  -->
  <!-- <listen_reuse_port>0</listen_reuse_port> -->
  {% if clickhouse_listen_reuse_port is defined -%}
  <listen_reuse_port>{{ clickhouse_listen_reuse_port }}</listen_reuse_port>
  {% endif -%}

  <!-- <listen_backlog>4096</listen_backlog> -->
  {% if clickhouse_listen_backlog is defined -%}
  <listen_backlog>{{ clickhouse_listen_backlog }}</listen_backlog>
  {% endif -%}

  <max_connections>{{ clickhouse_config.max_connections }}</max_connections>

  <!-- For 'Connection: keep-alive' in HTTP 1.1 -->
  <keep_alive_timeout>{{ clickhouse_config.keep_alive_timeout }}</keep_alive_timeout>

  <!-- gRPC protocol (see src/Server/grpc_protos/clickhouse_grpc.proto for the API) -->
  <!-- <grpc_port>9100</grpc_port> -->
  {% if clickhouse_grpc_port is defined -%}
  <grpc_port>{{ clickhouse_grpc_port }}</grpc_port>
  {% endif -%}
  <grpc>
    {% if clickhouse_grpc_port is defined -%}
    <grpc_port>{{ clickhouse_grpc_port }}</grpc_port>
    {% endif -%}
    <enable_ssl>{{ clickhouse_enable_ssl }}</enable_ssl>

    <!-- The following two files are used only if enable_ssl=1 -->
    {% if clickhouse_enable_ssl is true -%}
    <ssl_cert_file>{{ clickhouse_ssl_cert_file }}</ssl_cert_file>
    <ssl_key_file>{{ clickhouse_ssl_key_file }}</ssl_key_file>
    {% endif -%}

    <!-- Whether server will request client for a certificate -->
    <ssl_require_client_auth>{{ clickhouse_ssl_require_client_auth }}</ssl_require_client_auth>

    <!-- The following file is used only if ssl_require_client_auth=1 -->
    <ssl_ca_cert_file>{{ clickhouse_ssl_ca_cert_file }}</ssl_ca_cert_file>

    <!-- Default compression algorithm (applied if client doesn't specify another algorithm, see result_compression in QueryInfo).
    Supported algorithms: none, deflate, gzip, stream_gzip -->
    <compression>{{ clickhouse_grpc_compression }}</compression>

    <!-- Default compression level (applied if client doesn't specify another level, see result_compression in QueryInfo).
    Supported levels: none, low, medium, high -->
    <compression_level>{{ clickhouse_grpc_compression_level }}</compression_level>

    <!-- Send/receive message size limits in bytes. -1 means unlimited -->
    <max_send_message_size>{{ clickhouse_max_send_message_size }}</max_send_message_size>
    <max_receive_message_size>{{ clickhouse_max_receive_message_size }}</max_receive_message_size>

    <!-- Enable if you want very detailed logs -->
    <verbose_logs>{{ clickhouse_verbose_logs }}</verbose_logs>
  </grpc>

  <!-- Used with https_port and tcp_port_secure. Full ssl options list: https://github.com/ClickHouse-Extras/poco/blob/master/NetSSL_OpenSSL/include/Poco/Net/SSLManager.h#L71 -->
  <openSSL>
    <server> <!-- Used for https server AND secure tcp port -->
      <!-- openssl req -subj "/CN=localhost" -new -newkey rsa:2048 -days 365 -nodes -x509 -keyout /etc/clickhouse-server/server.key -out /etc/clickhouse-server/server.crt -->
      <certificateFile>{{ clickhouse_certificatefile }}</certificateFile>
      <privateKeyFile>{{ clickhouse_privatekeyfile }}</privateKeyFile>
      <!-- dhparams are optional. You can delete the <dhParamsFile> element.
        To generate dhparams, use the following command:
        openssl dhparam -out /etc/clickhouse-server/dhparam.pem 4096
        Only file format with BEGIN DH PARAMETERS is supported.
      -->
      <dhParamsFile>{{ clickhouse_dhparamsfile }}</dhParamsFile>
      <verificationMode>{{ clickhouse_verificationmode }}</verificationMode>
      <loadDefaultCAFile>{{ clickhouse_loaddefaultcafile_server }}</loadDefaultCAFile>
      <cacheSessions>{{ clickhouse_cachesessions_server }}</cacheSessions>
      <disableProtocols>{{ clickhouse_disableprotocols_server }}</disableProtocols>
      <preferServerCiphers>{{ clickhouse_preferserverciphers_server }}</preferServerCiphers>
    </server>

    <client> <!-- Used for connecting to https dictionary source and secured Zookeeper communication -->
      <loadDefaultCAFile>{{ clickhouse_loaddefaultcafile_client }}</loadDefaultCAFile>
      <cacheSessions>{{ clickhouse_cachesessions_client }}</cacheSessions>
      <disableProtocols>{{ clickhouse_disableprotocols_client }}</disableProtocols>
      <preferServerCiphers>{{ clickhouse_preferserverciphers_client }}</preferServerCiphers>
      <!-- Use for self-signed: <verificationMode>none</verificationMode> -->
      <invalidCertificateHandler>
        <!-- Use for self-signed: <name>AcceptCertificateHandler</name> -->
        <name>{{ clickhouse_invalidcertificatehandler.name }}</name>
      </invalidCertificateHandler>
    </client>
  </openSSL>

  <!-- Default root page on http[s] server. For example load UI from https://tabix.io/ when opening http://localhost:8123 -->
  <!--
  <http_server_default_response><![CDATA[<html ng-app="SMI2"><head><base href="http://ui.tabix.io/"></head><body><div ui-view="" class="content-ui"></div><script src="http://loader.tabix.io/master.js"></script></body></html>]]></http_server_default_response>
  -->
  {% if clickhouse_http_server_default_response is defined -%}
  <http_server_default_response>{{ clickhouse_http_server_default_response }}</http_server_default_response>
  {% endif -%}

  <!-- Maximum number of concurrent queries. -->
  <max_concurrent_queries>{{ clickhouse_config.max_concurrent_queries }}</max_concurrent_queries>

  <!-- Maximum memory usage (resident set size) for server process.
    Zero value or unset means default. Default is "max_server_memory_usage_to_ram_ratio" of available physical RAM.
    If the value is larger than "max_server_memory_usage_to_ram_ratio" of available physical RAM, it will be cut down.

    The constraint is checked on query execution time.
    If a query tries to allocate memory and the current memory usage plus allocation is greater
      than specified threshold, exception will be thrown.

    It is not practical to set this constraint to small values like just a few gigabytes,
    because memory allocator will keep this amount of memory in caches and the server will deny service of queries.
  -->
  <max_server_memory_usage>{{ clickhouse_config.max_server_memory_usage }}</max_server_memory_usage>

  <!-- Maximum number of threads in the Global thread pool.
  This will default to a maximum of 10000 threads if not specified.
  This setting will be useful in scenarios where there are a large number
  of distributed queries that are running concurrently but are idling most
  of the time, in which case a higher number of threads might be required.
  -->
  <max_thread_pool_size>{{ clickhouse_config.max_thread_pool_size }}</max_thread_pool_size>

  <!-- Number of workers to recycle connections in background (see also drain_timeout).
    If the pool is full, connection will be drained synchronously. -->
  <!-- <max_threads_for_connection_collector>10</max_threads_for_connection_collector> -->

  <!-- On memory constrained environments you may have to set this to value larger than 1.
    -->
  <max_server_memory_usage_to_ram_ratio>{{ clickhouse_config.max_server_memory_usage_to_ram_ratio }}</max_server_memory_usage_to_ram_ratio>

  <!-- Simple server-wide memory profiler. Collect a stack trace at every peak allocation step (in bytes).
  Data will be stored in system.trace_log table with query_id = empty string.
  Zero means disabled.
    -->
  <total_memory_profiler_step>{{ clickhouse_config.total_memory_profiler_step }}</total_memory_profiler_step>

  <!-- Collect random allocations and deallocations and write them into system.trace_log with 'MemorySample' trace_type.
    The probability is for every alloc/free regardless to the size of the allocation.
    Note that sampling happens only when the amount of untracked memory exceeds the untracked memory limit,
    which is 4 MiB by default but can be lowered if 'total_memory_profiler_step' is lowered.
    You may want to set 'total_memory_profiler_step' to 1 for extra fine grained sampling.
    -->
  <total_memory_tracker_sample_probability>{{ clickhouse_config.total_memory_tracker_sample_probability }}</total_memory_tracker_sample_probability>

  <!-- Set limit on number of open files (default: maximum). This setting makes sense on Mac OS X because getrlimit() fails to retrieve
  correct maximum value. -->
  <!-- <max_open_files>262144</max_open_files> -->
  {% if clickhouse_config.max_open_files is defined -%}
  <max_open_files>{{ clickhouse_config.max_open_files }}</max_open_files>
  {% endif -%}

  <!-- Size of cache of uncompressed blocks of data, used in tables of MergeTree family.
    In bytes. Cache is single for server. Memory is allocated only on demand.
    Cache is used when 'use_uncompressed_cache' user setting turned on (off by default).
    Uncompressed cache is advantageous only for very short queries and in rare cases.

    Note: uncompressed cache can be pointless for lz4, because memory bandwidth
    is slower than multi-core decompression on some server configurations.
    Enabling it can sometimes paradoxically make queries slower.
  -->
  <uncompressed_cache_size>{{ clickhouse_config.uncompressed_cache_size }}</uncompressed_cache_size>

  <!-- Approximate size of mark cache, used in tables of MergeTree family.
    In bytes. Cache is single for server. Memory is allocated only on demand.
    You should not lower this value.
  -->
  <mark_cache_size>{{ clickhouse_config.mark_cache_size }}</mark_cache_size>


  <!-- If you enable the `min_bytes_to_use_mmap_io` setting,
    the data in MergeTree tables can be read with mmap to avoid copying from kernel to userspace.
    It makes sense only for large files and helps only if data reside in page cache.
    To avoid frequent open/mmap/munmap/close calls (which are very expensive due to consequent page faults)
    and to reuse mappings from several threads and queries,
    the cache of mapped files is maintained. Its size is the number of mapped regions (usually equal to the number of mapped files).
    The amount of data in mapped files can be monitored
    in system.metrics, system.metric_log by the MMappedFiles, MMappedFileBytes metrics
    and in system.asynchronous_metrics, system.asynchronous_metrics_log by the MMapCacheCells metric,
    and also in system.events, system.processes, system.query_log, system.query_thread_log, system.query_views_log by the
    CreatedReadBufferMMap, CreatedReadBufferMMapFailed, MMappedFileCacheHits, MMappedFileCacheMisses events.
    Note that the amount of data in mapped files does not consume memory directly and is not accounted
    in query or server memory usage - because this memory can be discarded similar to OS page cache.
    The cache is dropped (the files are closed) automatically on removal of old parts in MergeTree,
    also it can be dropped manually by the SYSTEM DROP MMAP CACHE query.
  -->
  <mmap_cache_size>{{ clickhouse_config.mmap_cache_size }}</mmap_cache_size>

  <!-- Cache size in bytes for compiled expressions.-->
  <compiled_expression_cache_size>{{ clickhouse_config.compiled_expression_cache_size }}</compiled_expression_cache_size>

  <!-- Cache size in elements for compiled expressions.-->
  <compiled_expression_cache_elements_size>{{ clickhouse_config.compiled_expression_cache_elements_size }}</compiled_expression_cache_elements_size>

  <!-- Path to data directory, with trailing slash. -->
  <path>{{ clickhouse_base_path }}</path>

  <!-- Path to temporary data for processing hard queries. -->
  <tmp_path>{{ clickhouse_tmp_directory }}</tmp_path>

  <!-- Policy from the <storage_configuration> for the temporary files.
    If not set <tmp_path> is used, otherwise <tmp_path> is ignored.
    Notes:
    - move_factor              is ignored
    - keep_free_space_bytes    is ignored
    - max_data_part_size_bytes is ignored
    - you must have exactly one volume in that policy
  -->
  <!-- <tmp_policy>tmp</tmp_policy> -->
  {% if clickhouse_config.tmp_policy is defined -%}
  <tmp_policy>{{ clickhouse_config.tmp_policy }}</tmp_policy>
  {% endif -%}

  <!-- Directory with user provided files that are accessible by 'file' table function. -->
  <user_files_path>{{ clickhouse_user_files_directory }}</user_files_path>

  <!-- LDAP server definitions. -->
  <ldap_servers>
    <!-- List LDAP servers with their connection parameters here to later 1) use them as authenticators for dedicated local users,
    who have 'ldap' authentication mechanism specified instead of 'password', or to 2) use them as remote user directories.
      Parameters:
        host - LDAP server hostname or IP, this parameter is mandatory and cannot be empty.
        port - LDAP server port, default is 636 if enable_tls is set to true, 389 otherwise.
        bind_dn - template used to construct the DN to bind to.
          The resulting DN will be constructed by replacing all '{user_name}' substrings of the template with the actual
          user name during each authentication attempt.
        user_dn_detection - section with LDAP search parameters for detecting the actual user DN of the bound user.
          This is mainly used in search filters for further role mapping when the server is Active Directory. The
          resulting user DN will be used when replacing '{user_dn}' substrings wherever they are allowed. By default,
          user DN is set equal to bind DN, but once search is performed, it will be updated with to the actual detected
          user DN value.
          base_dn - template used to construct the base DN for the LDAP search.
            The resulting DN will be constructed by replacing all '{user_name}' and '{bind_dn}' substrings
            of the template with the actual user name and bind DN during the LDAP search.
          scope - scope of the LDAP search.
            Accepted values are: 'base', 'one_level', 'children', 'subtree' (the default).
          search_filter - template used to construct the search filter for the LDAP search.
            The resulting filter will be constructed by replacing all '{user_name}', '{bind_dn}', and '{base_dn}'
            substrings of the template with the actual user name, bind DN, and base DN during the LDAP search.
            Note, that the special characters must be escaped properly in XML.
        verification_cooldown - a period of time, in seconds, after a successful bind attempt, during which a user will be assumed
          to be successfully authenticated for all consecutive requests without contacting the LDAP server.
          Specify 0 (the default) to disable caching and force contacting the LDAP server for each authentication request.
        enable_tls - flag to trigger use of secure connection to the LDAP server.
          Specify 'no' for plain text (ldap://) protocol (not recommended).
          Specify 'yes' for LDAP over SSL/TLS (ldaps://) protocol (recommended, the default).
          Specify 'starttls' for legacy StartTLS protocol (plain text (ldap://) protocol, upgraded to TLS).
        tls_minimum_protocol_version - the minimum protocol version of SSL/TLS.
          Accepted values are: 'ssl2', 'ssl3', 'tls1.0', 'tls1.1', 'tls1.2' (the default).
        tls_require_cert - SSL/TLS peer certificate verification behavior.
          Accepted values are: 'never', 'allow', 'try', 'demand' (the default).
        tls_cert_file - path to certificate file.
        tls_key_file - path to certificate key file.
        tls_ca_cert_file - path to CA certificate file.
        tls_ca_cert_dir - path to the directory containing CA certificates.
        tls_cipher_suite - allowed cipher suite (in OpenSSL notation).
      Example:
        <my_ldap_server>
          <host>localhost</host>
          <port>636</port>
          <bind_dn>uid={user_name},ou=users,dc=example,dc=com</bind_dn>
          <verification_cooldown>300</verification_cooldown>
          <enable_tls>yes</enable_tls>
          <tls_minimum_protocol_version>tls1.2</tls_minimum_protocol_version>
          <tls_require_cert>demand</tls_require_cert>
          <tls_cert_file>/path/to/tls_cert_file</tls_cert_file>
          <tls_key_file>/path/to/tls_key_file</tls_key_file>
          <tls_ca_cert_file>/path/to/tls_ca_cert_file</tls_ca_cert_file>
          <tls_ca_cert_dir>/path/to/tls_ca_cert_dir</tls_ca_cert_dir>
          <tls_cipher_suite>ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:AES256-GCM-SHA384</tls_cipher_suite>
        </my_ldap_server>
      Example (typical Active Directory with configured user DN detection for further role mapping):
        <my_ad_server>
          <host>localhost</host>
          <port>389</port>
          <bind_dn>EXAMPLE\{user_name}</bind_dn>
          <user_dn_detection>
            <base_dn>CN=Users,DC=example,DC=com</base_dn>
            <search_filter>(&amp;(objectClass=user)(sAMAccountName={user_name}))</search_filter>
          </user_dn_detection>
          <enable_tls>no</enable_tls>
        </my_ad_server>
    -->
    {% if clickhouse_ldap is defined -%}
    {% for ldap_server in clickhouse_ldap %}
        <{{ ldap_server.servername }}>
          {% if ldap_server.host is defined -%}<host>{{ ldap_server.host }}</host>{% endif -%}
          {% if ldap_server.port is defined -%}<port>{{ ldap_server.port }}</port>{% endif -%}
          {% if ldap_server.bind_dn is defined -%}<bind_dn>{{ ldap_server.bind_dn }}</bind_dn>{% endif -%}
          {% if ldap_server.base_dn is defined or ldap_server.scope or ldap_server.search_filter -%}
          {% if clickhouse_auth_backend == 'AD' -%}<user_dn_detection>{% endif -%}
            {% if ldap_server.base_dn is defined -%}<base_dn>{{ ldap_server.base_dn }}</base_dn>{% endif -%}
            {% if ldap_server.scope is defined -%}<scope>{{ ldap_server.scope }}</scope>{% endif -%}
            {% if ldap_server.search_filter is defined -%}<search_filter>{{ ldap_server.search_filter }}</search_filter>{% endif -%}
          {% if clickhouse_auth_backend == 'AD' -%}</user_dn_detection>{% endif -%}
          {% endif -%}
          {% if ldap_server.verification_cooldown is defined -%}<verification_cooldown>{{ ldap_server.verification_cooldown }}</verification_cooldown>{% endif -%}
          {% if ldap_server.enable_tls is defined -%}<enable_tls>{{ ldap_server.enable_tls }}</enable_tls>{% endif -%}
          {% if ldap_server.tls_minimum_protocol_version is defined -%}<tls_minimum_protocol_version>{{ ldap_server.tls_minimum_protocol_version }}</tls_minimum_protocol_version>{% endif -%}
          {% if ldap_server.tls_require_cert is defined -%}<tls_require_cert>{{ ldap_server.tls_require_cert }}</tls_require_cert>{% endif -%}
          {% if ldap_server.tls_cert_file is defined -%}<tls_cert_file>{{ ldap_server.tls_cert_file }}</tls_cert_file>{% endif -%}
          {% if ldap_server.tls_key_file is defined -%}<tls_key_file>{{ ldap_server.tls_key_file }}</tls_key_file>{% endif -%}
          {% if ldap_server.tls_ca_cert_file is defined -%}<tls_ca_cert_file>{{ ldap_server.tls_ca_cert_file }}</tls_ca_cert_file>{% endif -%}
          {% if ldap_server.tls_ca_cert_dir is defined -%}<tls_ca_cert_dir>{{ ldap_server.tls_ca_cert_dir }}</tls_ca_cert_dir>{% endif -%}
          {% if ldap_server.tls_cipher_suite is defined -%}<tls_cipher_suite>{{ ldap_server.tls_cipher_suite }}</tls_cipher_suite>{% endif -%}
        </{{ ldap_server.servername }}>
    {% endfor %}
    {% endif -%}
  </ldap_servers>

  <!-- To enable Kerberos authentication support for HTTP requests (GSS-SPNEGO), for those users who are explicitly configured
      to authenticate via Kerberos, define a single 'kerberos' section here.
      Parameters:
      principal - canonical service principal name, that will be acquired and used when accepting security contexts.
          This parameter is optional, if omitted, the default principal will be used.
          This parameter cannot be specified together with 'realm' parameter.
      realm - a realm, that will be used to restrict authentication to only those requests whose initiator's realm matches it.
          This parameter is optional, if omitted, no additional filtering by realm will be applied.
          This parameter cannot be specified together with 'principal' parameter.
      Example:
      <kerberos s/>
      Example:
      <kerberos>
        <principal>HTTP/clickhouse.example.com@EXAMPLE.COM</principal>
      </kerberos>
      Example:
      <kerberos>
        <realm>EXAMPLE.COM</realm>
      </kerberos>
  -->
  {% if clickhouse_kerberos is defined -%}
  <kerberos>
  {% if clickhouse_kerberos.principal is defined%}<principal>{{ clickhouse_kerberos.principal }}</principal>{% endif -%}
  {% if clickhouse_kerberos.realm is defined%}<realm>{{ clickhouse_kerberos.realm }}</realm>{% endif -%}
  </kerberos>
  {% endif -%}

  <!-- Sources to read users, roles, access rights, profiles of settings, quotas. -->
  <user_directories>
    <users_xml>
      <!-- Path to configuration file with predefined users. -->
      <path>{{ clickhouse_users_file_name }}</path>
    </users_xml>
    <local_directory>
      <!-- Path to folder where users created by SQL commands are stored. -->
      <path>{{ clickhouse_access_control_directory }}</path>
    </local_directory>

    <!-- To add an LDAP server as a remote user directory of users that are not defined locally, define a single 'ldap' section
      with the following parameters:
        server - one of LDAP server names defined in    'ldap_servers' config section above.
        This parameter is mandatory and cannot be empty.
        roles - section with a list of locally defined roles that will be assigned to each user retrieved from the LDAP server.
        If no roles are specified here or assigned during role mapping (below), user will not be able to perform any
        actions after authentication.
        role_mapping - section with LDAP search parameters and mapping rules.
        When a user authenticates, while still bound to LDAP, an LDAP search is performed using search_filter and the
        name of the logged in user. For each entry found during that search, the value of the specified attribute is
        extracted. For each attribute value that has the specified prefix, the prefix is removed, and the rest of the
        value becomes the name of a local role defined in ClickHouse, which is expected to be created beforehand by
        CREATE ROLE command.
        There can be multiple 'role_mapping' sections defined inside the same 'ldap' section. All of them will be
        applied.
          base_dn - template used to construct the base DN for the LDAP search.
          The resulting DN will be constructed by replacing all '{user_name}', '{bind_dn}', and '{user_dn}'
          substrings of the template with the actual user name, bind DN, and user DN during each LDAP search.
          scope - scope of the LDAP search.
          Accepted values are: 'base', 'one_level', 'children', 'subtree' (the default).
          search_filter - template used to construct the search filter for the LDAP search.
          The resulting filter will be constructed by replacing all '{user_name}', '{bind_dn}', '{user_dn}', and
          '{base_dn}' substrings of the template with the actual user name, bind DN, user DN, and base DN during
          each LDAP search.
          Note, that the special characters must be escaped properly in XML.
          attribute - attribute name whose values will be returned by the LDAP search. 'cn', by default.
          prefix - prefix, that will be expected to be in front of each string in the original list of strings returned by
          the LDAP search. Prefix will be removed from the original strings and resulting strings will be treated
          as local role names. Empty, by default.
        Example:
        <ldap>
          <server>my_ldap_server</server>
          <roles>
            <my_local_role1 />
            <my_local_role2 />
          </roles>
          <role_mapping>
            <base_dn>ou=groups,dc=example,dc=com</base_dn>
            <scope>subtree</scope>
            <search_filter>(&amp;(objectClass=groupOfNames)(member={bind_dn}))</search_filter>
            <attribute>cn</attribute>
            <prefix>clickhouse_</prefix>
          </role_mapping>
        </ldap>
        Example (typical Active Directory with role mapping that relies on the detected user DN):
        <ldap>
          <server>my_ad_server</server>
          <role_mapping>
            <base_dn>CN=Users,DC=example,DC=com</base_dn>
            <attribute>CN</attribute>
            <scope>subtree</scope>
            <search_filter>(&amp;(objectClass=group)(member={user_dn}))</search_filter>
            <prefix>clickhouse_</prefix>
          </role_mapping>
        </ldap>
    -->
    {% if clickhouse_user_directories_ldap is defined -%}
    {% for user_directory in clickhouse_user_directories_ldap -%}
    <ldap>
      <server>{{ user_directory.server }}</server>
      {% if user_directory.roles is defined -%}
      <roles>
        {% for role in user_directory.roles -%}
        <{{ role }} />
        {% endfor -%}
      </roles>
      {% endif -%}
      {% if user_directory.role_mappings is defined -%}
      {% for role_mapping in user_directory.role_mappings -%}
      <role_mapping>
        <base_dn>{{ role_mapping.base_dn }}</base_dn>
        <scope>{{ role_mapping.scope }}</scope>
        <search_filter>{{ role_mapping.search_filter }}</search_filter>
        <attribute>{{ role_mapping.attribute }}</attribute>
        <prefix>{{ role_mapping.prefix }}</prefix>
      </role_mapping>
      {% endfor -%}
      {% endif -%}
    </ldap>
    {% endfor -%}
    {% endif -%}
  </user_directories>

  <!-- Default profile of settings. -->
  <default_profile>{{ clickhouse_config.default_profile }}</default_profile>

  <!-- Comma-separated list of prefixes for user-defined settings. -->
  <custom_settings_prefixes>{{ clickhouse_config.custom_settings_prefixes }}</custom_settings_prefixes>

  <!-- System profile of settings. This settings are used by internal processes (Distributed DDL worker and so on). -->
  <!-- <system_profile>default</system_profile> -->
  {% if clickhouse_config.system_profile is defined -%}
  <system_profile>{{ clickhouse_config.system_profile }}</system_profile>
  {% endif -%}

  <!-- Buffer profile of settings.
    This settings are used by Buffer storage to flush data to the underlying table.
      Default: used from system_profile directive.
  -->
  <!-- <buffer_profile>default</buffer_profile> -->
  {% if clickhouse_config.buffer_profile is defined -%}
  <buffer_profile>{{ clickhouse_config.buffer_profile }}</buffer_profile>
  {% endif -%}

  <!-- Default database. -->
  <default_database>{{ clickhouse_config.default_database }}</default_database>

  <!-- Server time zone could be set here.
    Time zone is used when converting between String and DateTime types,
    when printing DateTime in text formats and parsing DateTime from text,
    it is used in date and time related functions, if specific time zone was not passed as an argument.
    Time zone is specified as identifier from IANA time zone database, like UTC or Africa/Abidjan.
    If not specified, system time zone at server startup is used.
    Please note, that server could display time zone alias instead of specified name.
    Example: W-SU is an alias for Europe/Moscow and Zulu is an alias for UTC.
  -->
  <!-- <timezone>Europe/Moscow</timezone> -->
  {% if clickhouse_config.timezone is defined -%}
  <timezone>{{ clickhouse_config.timezone }}</timezone>
  {% endif -%}

  <!-- You can specify umask here (see "man umask"). Server will apply it on startup.
    Number is always parsed as octal. Default umask is 027 (other users cannot read logs, data files, etc; group can only read).
  -->
  <!-- <umask>022</umask> -->
  {% if clickhouse_config.umask is defined -%}
  <umask>{{ clickhouse_config.umask }}</umask>
  {% endif -%}
  <!-- Perform mlockall after startup to lower first queries latency
    and to prevent clickhouse executable from being paged out under high IO load.
    Enabling this option is recommended but will lead to increased startup time for up to a few seconds.
  -->
  <mlock_executable>{{ clickhouse_config.mlock_executable }}</mlock_executable>

  <!-- Reallocate memory for machine code ("text") using huge pages. Highly experimental. -->
  <remap_executable>{{ clickhouse_config.remap_executable }}</remap_executable>

  <!--
  <jdbc_bridge>
    <host>127.0.0.1</host>
    <port>9019</port>
  </jdbc_bridge>
  -->
  {% if clickhouse_jdbc_bridge is defined -%}
  <jdbc_bridge>
    <host>{{ clickhouse_jdbc_bridge.host }}</host>
    <port>{{ clickhouse_jdbc_bridge.port }}</port>
  </jdbc_bridge>
  {% endif -%}

  <!-- Configuration of clusters that could be used in Distributed tables.
    https://clickhouse.com/docs/en/operations/table_engines/distributed/
    -->
{% if clickhouse_remote_servers is defined %}
  <remote_servers>
{% for server in clickhouse_remote_servers %}
    <{{ server.servername }}>
{% if server.secret is defined %}
      <secret>{{ server.secret }}</secret>
{% endif %}
{% for shard in server.shards %}
      <shard>
{% if shard.internal_replication is defined %}
        <internal_replication>{{ shard.internal_replication }}</internal_replication>
{% endif %}
{% if shard.weight is defined %}
        <weight>{{ shard.weight }}</weight>
{% endif %}
{% for replica in shard.replicas %}
        <replica>
          <host>{{ replica.host }}</host>
          <port>{{ replica.port }}</port>
{% if replica.user is defined %}
          <user>{{ replica.user }}</user>
{% endif %}
{% if replica.password is defined %}
          <password>{{ replica.password }}</password>
{% endif %}
{% if replica.priority is defined %}
          <priority>{{ replica.priority }}</priority>
{% endif %}
{% if replica.secure is defined %}
          <secure>{{ replica.secure }}</secure>
{% endif %}
{% if replica.compression is defined %}
          <compression>{{ replica.compression }}</compression>
{% endif %}
        </replica>
{% endfor %}
      </shard>
{% endfor %}
    </{{ server.servername }}>
{% endfor %}
  </remote_servers>
{% endif %}

  <!--
  The list of hosts allowed to use in URL-related storage engines and table functions.
  If this section is not present in configuration, all hosts are allowed.
  -->
  <!--<remote_url_allow_hosts>-->
    <!-- Host should be specified exactly as in URL. The name is checked before DNS resolution.
    Example: "yandex.ru", "yandex.ru." and "www.yandex.ru" are different hosts.
      If port is explicitly specified in URL, the host:port is checked as a whole.
      If host specified here without port, any port with this host allowed.
      "yandex.ru" -> "yandex.ru:443", "yandex.ru:80" etc. is allowed, but "yandex.ru:80" -> only "yandex.ru:80" is allowed.
      If the host is specified as IP address, it is checked as specified in URL. Example: "[2a02:6b8:a::a]".
      If there are redirects and support for redirects is enabled, every redirect (the Location field) is checked.
      Host should be specified using the host xml tag:
        <host>yandex.ru</host>
    -->

    <!-- Regular expression can be specified. RE2 engine is used for regexps.
      Regexps are not aligned: don't forget to add ^ and $. Also don't forget to escape dot (.) metacharacter
      (forgetting to do so is a common source of error).
    -->
  <!--</remote_url_allow_hosts>-->
{% if clickhouse_remote_url_allow_hosts is defined %}
  <remote_url_allow_hosts>
{% for host in clickhouse_remote_url_allow_hosts %}
    <host>{{ host }}</host>
{% endfor %}
  </remote_url_allow_hosts>
{% endif %}

  <!-- If element has 'incl' attribute, then for it's value will be used corresponding substitution from another file.
  By default, path to file with substitutions is /etc/metrika.xml. It could be changed in config in 'include_from' element.
  Values for substitutions are specified in /clickhouse/name_of_substitution elements in that file.
  -->

<!-- Clickhouse Keeper -->
{% if clickhouse_keeper is defined %}
{% for keeper_server in clickhouse_keeper.keeper_servers %}
{% if keeper_server.server is defined and inventory_hostname == keeper_server.server %}
    <keeper_server>
        <!-- Clients use this port to connect (should match zookeeper port) -->
        <tcp_port>{{ clickhouse_keeper.tcp_port }}</tcp_port>
        <server_id>{{ keeper_server.id }}</server_id>
        <log_storage_path>{{ clickhouse_keeper.log_storage_path }}</log_storage_path>
        <snapshot_storage_path>{{ clickhouse_keeper.snapshot_storage_path }}</snapshot_storage_path>

        <coordination_settings>
            <operation_timeout_ms>{{ clickhouse_keeper.coordination_settings.operation_timeout_ms }}</operation_timeout_ms>
            <session_timeout_ms>{{ clickhouse_keeper.coordination_settings.session_timeout_ms }}</session_timeout_ms>
            <raft_logs_level>{{ clickhouse_keeper.coordination_settings.raft_logs_level }}</raft_logs_level>
        </coordination_settings>

        <raft_configuration>
{% for keeper_server in clickhouse_keeper.keeper_servers %}
            <server>
                <id>{{ keeper_server.id }}</id>
                <hostname>{{ keeper_server.hostname }}</hostname>
                <port>{{ keeper_server.port }}</port>
            </server>
{% endfor %}
        </raft_configuration>
    </keeper_server>
{% endif %}
{% endfor %}
{% endif %}

  <!-- ZooKeeper is used to store metadata about replicas, when using Replicated tables.
  Optional. If you don't use replicated tables, you could omit that.
  See https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/replication/
  -->

  <!--
  <zookeeper>
    <node>
      <host>example1</host>
      <port>2181</port>
    </node>
    <node>
      <host>example2</host>
      <port>2181</port>
    </node>
    <node>
      <host>example3</host>
      <port>2181</port>
    </node>
  </zookeeper>
  -->
{% if clickhouse_zookeeper is defined %}
  <zookeeper>
{% for node in clickhouse_zookeeper %}
    <node>
      <host>{{ node.host }}</host>
      <port>{{ node.port }}</port>
    </node>
{% endfor %}
  </zookeeper>
{% endif %}

  <!-- Substitutions for parameters of replicated tables.
  Optional. If you don't use replicated tables, you could omit that.

  See https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/replication/#creating-replicated-tables
  -->
  <!--
  <macros>
    <shard>01</shard>
    <replica>example01-01-1</replica>
  </macros>
  -->

{% if clickhouse_macros is defined %}
  <macros>
{% for macros in clickhouse_macros %}
{% if macros.server is defined and inventory_hostname in macros.server %}{{ macros.macro|indent(4, true) }}{% endif %}
{% if macros.server is not defined %}{{ macros.macro|indent(4, true) }}{% endif %}
{% endfor %}
  </macros>
{# Deprecated, please use clickhouse_macros instead of clickhouse_replicated_tables_macros #}
{% elif clickhouse_replicated_tables_macros is defined %}
  <macros>
{% for macros in clickhouse_replicated_tables_macros %}
{% if macros.server == inventory_hostname %}{{ macros.macro|indent(4, true) }}{% endif %}
{% endfor %}
  </macros>
{% endif %}

  <!-- Reloading interval for embedded dictionaries, in seconds. Default: 3600. -->
  <builtin_dictionaries_reload_interval>{{ clickhouse_config.builtin_dictionaries_reload_interval }}</builtin_dictionaries_reload_interval>

  <!-- Maximum session timeout, in seconds. Default: 3600. -->
  <max_session_timeout>{{ clickhouse_config.max_session_timeout }}</max_session_timeout>

  <!-- Default session timeout, in seconds. Default: 60. -->
  <default_session_timeout>{{ clickhouse_config.default_session_timeout }}</default_session_timeout>

  <!-- Sending data to Graphite for monitoring. Several sections can be defined. -->
  <!--
    interval - send every X second
    root_path - prefix for keys
    hostname_in_path - append hostname to root_path (default = true)
    metrics - send data from table system.metrics
    events - send data from table system.events
    asynchronous_metrics - send data from table system.asynchronous_metrics
  -->
  <!--
  <graphite>
    <host>localhost</host>
    <port>42000</port>
    <timeout>0.1</timeout>
    <interval>60</interval>
    <root_path>one_min</root_path>
    <hostname_in_path>true</hostname_in_path>
    <metrics>true</metrics>
    <events>true</events>
    <events_cumulative>false</events_cumulative>
    <asynchronous_metrics>true</asynchronous_metrics>
  </graphite>
  <graphite>
    <host>localhost</host>
    <port>42000</port>
    <timeout>0.1</timeout>
    <interval>1</interval>
    <root_path>one_sec</root_path>
    <metrics>true</metrics>
    <events>true</events>
    <events_cumulative>false</events_cumulative>
    <asynchronous_metrics>false</asynchronous_metrics>
  </graphite>
  -->
{% if clickhouse_graphite is defined %}
{% for graphite in clickhouse_graphite %}
  <graphite>
    <host>{{ graphite.host }}</host>
    <port>{{ graphite.port }}</port>
    <timeout>{{ graphite.timeout }}</timeout>
{% if graphite.interval is defined %}
    <interval>{{ graphite.interval }}</interval>
{% endif %}
{% if graphite.root_path is defined %}
    <root_path>{{ graphite.root_path }}</root_path>
{% endif %}
{% if graphite.hostname_in_path is defined %}
    <hostname_in_path>{{ graphite.hostname_in_path }}</hostname_in_path>
{% endif %}
{% if graphite.metrics is defined %}
    <metrics>{{ graphite.metrics }}</metrics>
{% endif %}
{% if graphite.events is defined %}
    <events>{{ graphite.events }}</events>
{% endif %}
{% if graphite.events_cumulative is defined %}
    <events_cumulative>{{ graphite.events_cumulative }}</events_cumulative>
{% endif %}
{% if graphite.asynchronous_metrics is defined %}
    <asynchronous_metrics>{{ graphite.asynchronous_metrics }}</asynchronous_metrics>
{% endif %}
  </graphite>
{% endfor %}
{% endif %}

  <!-- Serve endpoint for Prometheus monitoring. -->
  <!--
    endpoint - mertics path (relative to root, statring with "/")
    port - port to setup server. If not defined or 0 than http_port used
    metrics - send data from table system.metrics
    events - send data from table system.events
    asynchronous_metrics - send data from table system.asynchronous_metrics
    status_info - send data from different component from CH, ex: Dictionaries status
  -->
  <!--
  <prometheus>
    <endpoint>/metrics</endpoint>
    <port>9363</port>
    <metrics>true</metrics>
    <events>true</events>
    <asynchronous_metrics>true</asynchronous_metrics>
    <status_info>true</status_info>
  </prometheus>
  -->
{% if clickhouse_prometheus is defined %}
  <prometheus>
    <endpoint>{{ clickhouse_prometheus.endpoint }}</endpoint>
    <port>{{ clickhouse_prometheus.port }}</port>
    <metrics>{{ clickhouse_prometheus.metrics }}</metrics>
    <events>{{ clickhouse_prometheus.events }}</events>
    <asynchronous_metrics>{{ clickhouse_prometheus.asynchronous_metrics }}</asynchronous_metrics>
    <status_info>{{ clickhouse_prometheus.status_info }}</status_info>
  </prometheus>
{% endif %}

  <!-- Query log. Used only for queries with setting log_queries = 1. -->
  <query_log>
    <!-- What table to insert data. If table is not exist, it will be created.
      When query log structure is changed after system update,
        then old table will be renamed and new table will be created automatically.
    -->
    <database>{{ clickhouse_tables_log.query_log.database }}</database>
    <table>{{ clickhouse_tables_log.query_log.table }}</table>
    <!--
      PARTITION BY expr: https://clickhouse.com/docs/en/table_engines/mergetree-family/custom_partitioning_key/
      Example:
        event_date
        toMonday(event_date)
        toYYYYMM(event_date)
        toStartOfHour(event_time)
    -->
{% if clickhouse_tables_log.query_log.partition_by is defined %}
    <partition_by>{{ clickhouse_tables_log.query_log.partition_by }}</partition_by>
{% endif %}
    <!--
      Table TTL specification: https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree/#mergetree-table-ttl
      Example:
        event_date + INTERVAL 1 WEEK
        event_date + INTERVAL 7 DAY DELETE
        event_date + INTERVAL 2 WEEK TO DISK 'bbb'

    <ttl>event_date + INTERVAL 30 DAY DELETE</ttl>
    -->
{% if clickhouse_tables_log.query_log.ttl is defined %}
    <ttl>{{ clickhouse_tables_log.query_log.ttl }}</ttl>
{% endif %}

    <!-- Instead of partition_by, you can provide full engine expression (starting with ENGINE = ) with parameters,
      Example: <engine>ENGINE = MergeTree PARTITION BY toYYYYMM(event_date) ORDER BY (event_date, event_time) SETTINGS index_granularity = 1024</engine>
    -->
{% if clickhouse_tables_log.query_log.engine is defined %}
    <engine>{{ clickhouse_tables_log.query_log.engine }}</engine>
{% endif %}

    <!-- Interval of flushing data. -->
    <flush_interval_milliseconds>{{ clickhouse_tables_log.query_log.flush_interval_milliseconds }}</flush_interval_milliseconds>
  </query_log>

  <!-- Trace log. Stores stack traces collected by query profilers.
    See query_profiler_real_time_period_ns and query_profiler_cpu_time_period_ns settings. -->
  <trace_log>
    <database>{{ clickhouse_tables_log.trace_log.database }}</database>
    <table>{{ clickhouse_tables_log.trace_log.table }}</table>
    <partition_by>{{ clickhouse_tables_log.trace_log.partition_by }}</partition_by>
    <flush_interval_milliseconds>{{ clickhouse_tables_log.trace_log.flush_interval_milliseconds }}</flush_interval_milliseconds>
{% if clickhouse_tables_log.trace_log.ttl is defined %}
    <ttl>{{ clickhouse_tables_log.trace_log.ttl }}</ttl>
{% endif %}
  </trace_log>

  <!-- Query thread log. Has information about all threads participated in query execution.
  Used only for queries with setting log_query_threads = 1. -->
  <query_thread_log>
    <database>{{ clickhouse_tables_log.thread_log.database }}</database>
    <table>{{ clickhouse_tables_log.thread_log.table }}</table>
    <partition_by>{{ clickhouse_tables_log.thread_log.partition_by }}</partition_by>
    <flush_interval_milliseconds>{{ clickhouse_tables_log.thread_log.flush_interval_milliseconds }}</flush_interval_milliseconds>
{% if clickhouse_tables_log.thread_log.ttl is defined %}
    <ttl>{{ clickhouse_tables_log.thread_log.ttl }}</ttl>
{% endif %}
  </query_thread_log>

  <!-- Query views log. Has information about all dependent views associated with a query.
    Used only for queries with setting log_query_views = 1. -->
  <query_views_log>
    <database>{{ clickhouse_tables_log.views_log.database }}</database>
    <table>{{ clickhouse_tables_log.views_log.table }}</table>
    <partition_by>{{ clickhouse_tables_log.views_log.partition_by }}</partition_by>
    <flush_interval_milliseconds>{{ clickhouse_tables_log.views_log.flush_interval_milliseconds }}</flush_interval_milliseconds>
{% if clickhouse_tables_log.views_log.ttl is defined %}
    <ttl>{{ clickhouse_tables_log.views_log.ttl }}</ttl>
{% endif %}
  </query_views_log>

  <!-- Uncomment if use part log.
    Part log contains information about all actions with parts in MergeTree tables (creation, deletion, merges, downloads).-->
  <part_log>
    <database>{{ clickhouse_tables_log.part_log.database }}</database>
    <table>{{ clickhouse_tables_log.part_log.table }}</table>
    <partition_by>{{ clickhouse_tables_log.part_log.partition_by }}</partition_by>
    <flush_interval_milliseconds>{{ clickhouse_tables_log.part_log.flush_interval_milliseconds }}</flush_interval_milliseconds>
{% if clickhouse_tables_log.part_log.ttl is defined %}
    <ttl>{{ clickhouse_tables_log.part_log.ttl }}</ttl>
{% endif %}
  </part_log>

  <!-- Uncomment to write text log into table.
    Text log contains all information from usual server log but stores it in structured and efficient way.
    The level of the messages that goes to the table can be limited (<level>), if not specified all messages will go to the table.
  <text_log>
    <database>system</database>
    <table>text_log</table>
    <flush_interval_milliseconds>7500</flush_interval_milliseconds>
    <level></level>
  </text_log>
  -->
{% if clickhouse_tables_log.text_log is defined %}
  <text_log>
    <database>{{ clickhouse_tables_log.text_log.database }}</database>
    <table>{{ clickhouse_tables_log.text_log.table }}</table>
    <flush_interval_milliseconds>{{ clickhouse_tables_log.text_log.flush_interval_milliseconds }}</flush_interval_milliseconds>
{% if clickhouse_tables_log.text_log.ttl is defined %}
    <ttl>{{ clickhouse_tables_log.text_log.ttl }}</ttl>
{% endif %}
{% if clickhouse_tables_log.text_log.level is defined %}
    <level>clickhouse_tables_log.text_log.level</level>
{% endif %}
  </text_log>
{% endif %}

  <!-- Metric log contains rows with current values of ProfileEvents, CurrentMetrics collected with "collect_interval_milliseconds" interval. -->
  <metric_log>
    <database>{{ clickhouse_tables_log.metric_log.database }}</database>
    <table>{{ clickhouse_tables_log.metric_log.table }}</table>
    <flush_interval_milliseconds>{{ clickhouse_tables_log.metric_log.flush_interval_milliseconds }}</flush_interval_milliseconds>
{% if clickhouse_tables_log.metric_log.ttl is defined %}
    <ttl>{{ clickhouse_tables_log.metric_log.ttl }}</ttl>
{% endif %}
    <collect_interval_milliseconds>{{ clickhouse_tables_log.metric_log.collect_interval_milliseconds }}</collect_interval_milliseconds>
  </metric_log>

  <!--
    Asynchronous metric log contains values of metrics from
    system.asynchronous_metrics.
  -->
  <asynchronous_metric_log>
    <database>{{ clickhouse_tables_log.asynchronous_metric_log.database }}</database>
    <table>{{ clickhouse_tables_log.asynchronous_metric_log.table }}</table>
    <!--
      Asynchronous metrics are updated once a minute, so there is
      no need to flush more often.
    -->
    <flush_interval_milliseconds>{{ clickhouse_tables_log.asynchronous_metric_log.flush_interval_milliseconds }}</flush_interval_milliseconds>
{% if clickhouse_tables_log.asynchronous_metric_log.ttl is defined %}
    <ttl>{{ clickhouse_tables_log.asynchronous_metric_log.ttl }}</ttl>
{% endif %}
  </asynchronous_metric_log>

  <!--
    OpenTelemetry log contains OpenTelemetry trace spans.
  -->
  <opentelemetry_span_log>
    <!--
      The default table creation code is insufficient, this <engine> spec
      is a workaround. There is no 'event_time' for this log, but two times,
      start and finish. It is sorted by finish time, to avoid inserting
      data too far away in the past (probably we can sometimes insert a span
      that is seconds earlier than the last span in the table, due to a race
      between several spans inserted in parallel). This gives the spans a
      global order that we can use to e.g. retry insertion into some external
      system.
    -->
    <engine>
      {{ clickhouse_tables_log.opentelemetry_span_log.engine }}
    </engine>
    <database>{{ clickhouse_tables_log.opentelemetry_span_log.database }}</database>
    <table>{{ clickhouse_tables_log.opentelemetry_span_log.table }}</table>
    <flush_interval_milliseconds>{{ clickhouse_tables_log.opentelemetry_span_log.flush_interval_milliseconds }}</flush_interval_milliseconds>
  </opentelemetry_span_log>


  <!-- Crash log. Stores stack traces for fatal errors.
    This table is normally empty. -->
  <crash_log>
    <database>{{ clickhouse_tables_log.crash_log.database }}</database>
    <table>{{ clickhouse_tables_log.crash_log.table }}</table>
    <partition_by>{{ clickhouse_tables_log.crash_log.partition_by }}</partition_by>
    <flush_interval_milliseconds>{{ clickhouse_tables_log.crash_log.flush_interval_milliseconds }}</flush_interval_milliseconds>
{% if clickhouse_tables_log.crash_log.ttl is defined %}
    <ttl>{{ clickhouse_tables_log.crash_log.ttl }}</ttl>
{% endif %}
  </crash_log>

  <!-- Session log. Stores user log in (successful or not) and log out events. -->
  <session_log>
    <database>{{ clickhouse_tables_log.session_log.database }}</database>
    <table>{{ clickhouse_tables_log.session_log.table }}</table>
    <partition_by>{{ clickhouse_tables_log.session_log.partition_by }}</partition_by>
    <flush_interval_milliseconds>{{ clickhouse_tables_log.session_log.flush_interval_milliseconds }}</flush_interval_milliseconds>
{% if clickhouse_tables_log.session_log.ttl is defined %}
    <ttl>{{ clickhouse_tables_log.session_log.ttl }}</ttl>
{% endif %}
  </session_log>

  <!-- Parameters for embedded dictionaries, used in Yandex.Metrica.
    See https://clickhouse.com/docs/en/dicts/internal_dicts/
  -->

  <!-- Path to file with region hierarchy. -->
  <!-- <path_to_regions_hierarchy_file>/opt/geo/regions_hierarchy.txt</path_to_regions_hierarchy_file> -->
{% if clickhouse_config.regions_hierarchy_file is defined %}
  <path_to_regions_hierarchy_file>{{ clickhouse_config.regions_hierarchy_file }}</path_to_regions_hierarchy_file>
{% endif %}

  <!-- Path to directory with files containing names of regions -->
  <!-- <path_to_regions_names_files>/opt/geo/</path_to_regions_names_files> -->
{% if clickhouse_config.regions_names_files_path is defined %}
  <path_to_regions_names_files>{{ clickhouse_config.regions_names_files_path }}</path_to_regions_names_files>
{% endif %}

  <!-- <top_level_domains_path>/var/lib/clickhouse/top_level_domains/</top_level_domains_path> -->
{% if clickhouse_config.top_level_domains_path is defined %}
  <top_level_domains_path>{{ clickhouse_config.top_level_domains_path }}</top_level_domains_path>
{% endif %}
  <!-- Custom TLD lists.
    Format: <name>/path/to/file</name>
    Changes will not be applied w/o server restart.
    Path to the list is under top_level_domains_path (see above).
  -->
  <top_level_domains_lists>
    <!--
    <public_suffix_list>/path/to/public_suffix_list.dat</public_suffix_list>
    -->
{% if clickhouse_config.top_level_domains is defined %}
{% for domain in clickhouse_config.top_level_domains %}
    <{{ domain.name }}>{{ domain.path }}</{{ domain.name }}>
{% endfor %}
{% endif %}
  </top_level_domains_lists>

  <!-- Configuration of external dictionaries. See:
    https://clickhouse.com/docs/en/sql-reference/dictionaries/external-dictionaries/external-dicts
  -->
  <dictionaries_config>{{ clickhouse_config.dictionaries_config }}</dictionaries_config>

  <!-- Configuration of user defined executable functions -->
  <user_defined_executable_functions_config>{{ clickhouse_config.user_defined_executable_functions_config }}</user_defined_executable_functions_config>

  <!-- Uncomment if you want data to be compressed 30-100% better.
    Don't do that if you just started using ClickHouse.
    -->
  <!--
  <compression>
    <!- - Set of variants. Checked in order. Last matching case wins. If nothing matches, lz4 will be used. - ->
    <case>

      <!- - Conditions. All must be satisfied. Some conditions may be omitted. - ->
      <min_part_size>10000000000</min_part_size>        <!- - Min part size in bytes. - ->
      <min_part_size_ratio>0.01</min_part_size_ratio>   <!- - Min size of part relative to whole table size. - ->

      <!- - What compression method to use. - ->
      <method>zstd</method>
    </case>
  </compression>
  -->
{% if clickhouse_compression is defined %}
  <compression>
{% for case in clickhouse_compression %}
    <case>
{% if case.min_part_size is defined %}
      <min_part_size>{{ case.min_part_size }}</min_part_size>
{% endif %}
{% if case.min_part_size_ratio is defined %}
      <min_part_size_ratio>{{ case.min_part_size_ratio }}</min_part_size_ratio>
{% endif %}
{% if case.method is defined %}
      <method>{{ case.method }}</method>
{% endif %}
{% if case.level is defined %}
      <level>{{ case.level }}</level>
{% endif %}
    </case>
{% endfor %}
  </compression>
{% endif %}

  <!-- Configuration of encryption. The server executes a command to
    obtain an encryption key at startup if such a command is
    defined, or encryption codecs will be disabled otherwise. The
    command is executed through /bin/sh and is expected to write
    a Base64-encoded key to the stdout. -->
  <encryption_codecs>
    <!-- aes_128_gcm_siv -->
      <!-- Example of getting hex key from env -->
      <!-- the code should use this key and throw an exception if its length is not 16 bytes -->
      <!--key_hex from_env="..."></key_hex -->

      <!-- Example of multiple hex keys. They can be imported from env or be written down in config-->
      <!-- the code should use these keys and throw an exception if their length is not 16 bytes -->
      <!-- key_hex id="0">...</key_hex -->
      <!-- key_hex id="1" from_env=".."></key_hex -->
      <!-- key_hex id="2">...</key_hex -->
      <!-- current_key_id>2</current_key_id -->

      <!-- Example of getting hex key from config -->
      <!-- the code should use this key and throw an exception if its length is not 16 bytes -->
      <!-- key>...</key -->

      <!-- example of adding nonce -->
      <!-- nonce>...</nonce -->

    <!-- /aes_128_gcm_siv -->
{% if clickhouse_encryption is defined %}
    <{{ clickhouse_encryption.encryption }}>
{% for key in clickhouse_encryption.elements %}
      <{{ key.type }}{% if key.id is defined %} id={{ key.id }}{% endif %}{% if key.from_env is defined %} from_env={{ key.from_env }}{% endif %}>{% if key.value is defined %}{{ key.value }}{% endif %}</{{ key.type }}>
{% endfor %}
{% if clickhouse_encryption.current_key_id is defined %}
      <current_key_id>{{ clickhouse_encryption.current_key_id }}</current_key_id>
{% endif %}
{% if clickhouse_encryption.nonce is defined %}
      <nonce>{{ clickhouse_encryption.nonce }}</nonce>
{% endif %}
    </{{ clickhouse_encryption.encryption }}>
{% endif %}
  </encryption_codecs>

  <!-- Default arguments passed to Replicated table engines -->
{% if clickhouse_default_replica_path is defined %}
  <default_replica_path>{{ clickhouse_default_replica_path }}</default_replica_path>
{% endif %}
{% if clickhouse_default_replica_name is defined %}
  <default_replica_name>{{ clickhouse_default_replica_name }}</default_replica_name>
{% endif %}


  <!-- Allow to execute distributed DDL queries (CREATE, DROP, ALTER, RENAME) on cluster.
    Works only if ZooKeeper is enabled. Comment it if such functionality isn't required. -->
{% if clickhouse_zookeeper is defined and clickhouse_distributed_ddl is defined %}
  <distributed_ddl>
    <!-- Path in ZooKeeper to queue with DDL queries -->
    <path>{{ clickhouse_distributed_ddl.path }}</path>

    <!-- Settings from this profile will be used to execute DDL queries -->
    <!-- <profile>default</profile> -->
{% if clickhouse_distributed_ddl.profile is defined %}
    <profile>{{ clickhouse_distributed_ddl.profile }}</profile>
{% endif %}

    <!-- Controls how much ON CLUSTER queries can be run simultaneously. -->
    <!-- <pool_size>1</pool_size> -->
{% if clickhouse_distributed_ddl.pool_size is defined %}
    <pool_size>{{ clickhouse_distributed_ddl.pool_size }}</pool_size>
{% endif %}

    <!--
      Cleanup settings (active tasks will not be removed)
    -->

    <!-- Controls task TTL (default 1 week) -->
    <!-- <task_max_lifetime>604800</task_max_lifetime> -->
{% if clickhouse_distributed_ddl.task_max_lifetime %}
    <task_max_lifetime>{{ clickhouse_distributed_ddl.task_max_lifetime }}</task_max_lifetime>
{% endif %}

    <!-- Controls how often cleanup should be performed (in seconds) -->
    <!-- <cleanup_delay_period>60</cleanup_delay_period> -->
{% if clickhouse_distributed_ddl.cleanup_delay_period %}
    <cleanup_delay_period>{{ clickhouse_distributed_ddl.cleanup_delay_period }}</cleanup_delay_period>
{% endif %}

    <!-- Controls how many tasks could be in the queue -->
    <!-- <max_tasks_in_queue>1000</max_tasks_in_queue> -->
{% if clickhouse_distributed_ddl.max_tasks_in_queue %}
    <max_tasks_in_queue>{{ clickhouse_distributed_ddl.max_tasks_in_queue }}</max_tasks_in_queue>
{% endif %}
  </distributed_ddl>
{% endif %}

  <!-- Settings to fine tune MergeTree tables. See documentation in source code, in MergeTreeSettings.h -->
  <!--
  <merge_tree>
  </merge_tree>
    <max_suspicious_broken_parts>5</max_suspicious_broken_parts>
  </merge_tree>
  -->
{% if clickhouse_mergetree_settings is defined %}
  <merge_tree>
{% for setting in clickhouse_mergetree_settings|dict2items %}
    <{{ setting.key }}>{{ setting.value }}</{{ setting.key }}>
{% endfor %}
  </merge_tree>
{% endif %}

  <!-- Protection from accidental DROP.
    If size of a MergeTree table is greater than max_table_size_to_drop (in bytes) than table could not be dropped with any DROP query.
    If you want do delete one table and don't want to change clickhouse-server config, you could create special file <clickhouse-path>/flags/force_drop_table and make DROP once.
    By default max_table_size_to_drop is 50GB; max_table_size_to_drop=0 allows to DROP any tables.
    The same for max_partition_size_to_drop.
    Uncomment to disable protection.
  -->
  <!-- <max_table_size_to_drop>0</max_table_size_to_drop> -->
  <!-- <max_partition_size_to_drop>0</max_partition_size_to_drop> -->
{% if clickhouse_config.max_table_size_to_drop is defined %}
  <max_table_size_to_drop>{{ clickhouse_config.max_table_size_to_drop }}</max_table_size_to_drop>
{% endif %}
{% if clickhouse_config.max_partition_size_to_drop is defined %}
  <max_partition_size_to_drop>{{ clickhouse_config.max_partition_size_to_drop }}</max_partition_size_to_drop>
{% endif %}

  <!-- Example of parameters for GraphiteMergeTree table engine -->
{% if clickhouse_graphitemergetree_settings is defined %}
  <{{ clickhouse_graphitemergetree_settings.name }}>
{% if clickhouse_graphitemergetree_settings.pattern is defined %}
    <pattern>
      <regexp>{{ clickhouse_graphitemergetree_settings.pattern.regexp }}</regexp>
{% if clickhouse_graphitemergetree_settings.pattern.function is defined %}
      <function>{{ clickhouse_graphitemergetree_settings.pattern.function }}</function>
{% endif %}
{% for retention in clickhouse_graphitemergetree_settings.pattern.retention %}
      <retention>
        <age>{{ retention.age }}</age>
        <precision>{{ retention.precision }}</precision>
      </retention>
{% endfor %}
    </pattern>
{% endif %}
    <default>
{% if clickhouse_graphitemergetree_settings.default.function is defined %}
      <function>{{ clickhouse_graphitemergetree_settings.default.function }}</function>
{% endif %}
{% for retention in clickhouse_graphitemergetree_settings.default.retention %}
      <retention>
        <age>{{ retention.age }}</age>
        <precision>{{ retention.precision }}</precision>
      </retention>
{% endfor %}
    </default>
  </{{ clickhouse_graphitemergetree_settings.name }}>
{% endif %}

  <!-- Directory in <clickhouse-path> containing schema files for various input formats.
    The directory will be created if it doesn't exist.
    -->
  <format_schema_path>{{ clickhouse_config.format_schema_path }}</format_schema_path>

  <!-- Default query masking rules, matching lines would be replaced with something else in the logs
    (both text logs and system.query_log).
    name - name for the rule (optional)
    regexp - RE2 compatible regular expression (mandatory)
    replace - substitution string for sensitive data (optional, by default - six asterisks)
  -->
{% if clickhouse_query_masking_rules is defined %}
  <query_masking_rules>
{% for rule in clickhouse_query_masking_rules %}
    <rule>
      <name>{{ rule.name }}</name>
      <regexp>{{ rule.regexp }}</regexp>
      <replace>{{ rule.replace }}</replace>
    </rule>
{% endfor %}
  </query_masking_rules>
{% endif %}

  <!-- Uncomment to use custom http handlers.
    rules are checked from top to bottom, first match runs the handler
      url - to match request URL, you can use 'regex:' prefix to use regex match(optional)
      methods - to match request method, you can use commas to separate multiple method matches(optional)
      headers - to match request headers, match each child element(child element name is header name), you can use 'regex:' prefix to use regex match(optional)
    handler is request handler
      type - supported types: static, dynamic_query_handler, predefined_query_handler
      query - use with predefined_query_handler type, executes query when the handler is called
      query_param_name - use with dynamic_query_handler type, extracts and executes the value corresponding to the <query_param_name> value in HTTP request params
      status - use with static type, response status code
      content_type - use with static type, response content-type
      response_content - use with static type, Response content sent to client, when using the prefix 'file://' or 'config://', find the content from the file or configuration send to client.

  <http_handlers>
    <rule>
      <url>/</url>
      <methods>POST,GET</methods>
      <headers><pragma>no-cache</pragma></headers>
      <handler>
        <type>dynamic_query_handler</type>
        <query_param_name>query</query_param_name>
      </handler>
    </rule>

    <rule>
      <url>/predefined_query</url>
      <methods>POST,GET</methods>
      <handler>
        <type>predefined_query_handler</type>
        <query>SELECT * FROM system.settings</query>
      </handler>
    </rule>

    <rule>
      <handler>
        <type>static</type>
        <status>200</status>
        <content_type>text/plain; charset=UTF-8</content_type>
        <response_content>config://http_server_default_response</response_content>
      </handler>
    </rule>
  </http_handlers>
  -->
{% if clickhouse_http_handlers is defined %}
  <http_handlers>
{% for rule in clickhouse_http_handlers %}
    <rule>
{% if rule.url is defined %}
      <url>{{ rule.url }}</url>
{% endif %}
{% if rule.methods is defined %}
      <methods>{{ rule.methods }}</methods>
{% endif %}
{% if rule.headers is defined %}
      <headers>{{ rule.headers }}</headers>
{% endif %}
      <handler>
{% if rule.handler.type is defined %}
        <type>{{ rule.handler.type }}</type>
{% endif %}
{% if rule.handler.type == 'predefined_query_handler' %}
        <query>{{ rule.handler.query }}</query>
{% elif rule.handler.type == 'dynamic_query_handler' %}
        <query_param_name>{{ rule.handler.query_param_name }}</query_param_name>
{% endif %}
{% if rule.handler.status is defined %}
        <status>{{ rule.handler.status }}</status>
{% endif %}
{% if rule.handler.content_type is defined %}
        <content_type>{{ rule.handler.content_type }}</content_type>
{% endif %}
{% if rule.handler.response_content is defined %}
        <response_content>{{ rule.handler.response_content }}</response_content>
{% endif %}
      </handler>
    </rule>
{% endfor %}
  </http_handlers>
{% endif %}

  <send_crash_reports>
    <!-- Changing <enabled> to true allows sending crash reports to -->
    <!-- the ClickHouse core developers team via Sentry https://sentry.io -->
    <!-- Doing so at least in pre-production environments is highly appreciated -->
    <enabled>{{ clickhouse_send_crash_reports.enabled }}</enabled>
    <!-- Change <anonymize> to true if you don't feel comfortable attaching the server hostname to the crash report -->
    <anonymize>{{ clickhouse_send_crash_reports.anonymize }}</anonymize>
    <!-- Default endpoint should be changed to different Sentry DSN only if you have -->
    <!-- some in-house engineers or hired consultants who're going to debug ClickHouse issues for you -->
    <endpoint>{{ clickhouse_send_crash_reports.endpoint }}</endpoint>
  </send_crash_reports>

  <!-- Uncomment to disable ClickHouse internal DNS caching. -->
  <!-- <disable_internal_dns_cache>1</disable_internal_dns_cache> -->
{% if clickhouse_config.disable_internal_dns_cache is defined %}
  <disable_internal_dns_cache>{{ clickhouse_config.disable_internal_dns_cache }}</disable_internal_dns_cache>
{% endif %}

  <!-- You can also configure rocksdb like this: -->
  <!--
  <rocksdb>
    <options>
      <max_background_jobs>8</max_background_jobs>
    </options>
    <column_family_options>
      <num_levels>2</num_levels>
    </column_family_options>
    <tables>
      <table>
        <name>TABLE</name>
        <options>
          <max_background_jobs>8</max_background_jobs>
        </options>
        <column_family_options>
          <num_levels>2</num_levels>
        </column_family_options>
      </table>
    </tables>
  </rocksdb>
  -->
{% if clickhouse_rocksdb is defined %}
  <rocksdb>
{% if clickhouse_rocksdb.db_options is defined %}
    <options>
{% for option in clickhouse_rocksdb.db_options|dict2items %}
      <{{ option.key }}>{{ option.value }}</{{ option.key }}>
{% endfor %}
    </options>
{% endif %}
{% if clickhouse_rocksdb.db_options is defined %}
    <column_family_options>
{% for option in clickhouse_rocksdb.cf_options|dict2items %}
      <{{ option.key }}>{{ option.value }}</{{ option.key }}>
{% endfor %}
    </column_family_options>
{% endif %}
{% if clickhouse_rocksdb.table_options is defined %}
    <tables>
{% for table in clickhouse_rocksdb.table_options %}
      <table>
        <name>{{ table.name }}</name>
        <options>
{% for option in table.options|dict2items %}
          <{{ option.key }}>{{ option.value }}</{{ option.key }}>
{% endfor %}
        </options>
        <column_family_options>
{% for option in table.cf_options|dict2items %}
          <{{ option.key }}>{{ option.value }}</{{ option.key }}>
{% endfor %}
        </column_family_options>
      </table>
{% endfor %}
    </tables>
{% endif %}
  </rocksdb>
{% endif %}

{% if clickhouse_config_xml_extra_config is defined %}
{{ clickhouse_config_xml_extra_config|indent(2, true) }}
{% endif %}
</clickhouse>
